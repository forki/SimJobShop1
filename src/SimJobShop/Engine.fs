module SimJobShop.Engine

open System
open Common

/// Represents a command that is scheduled to be excecuted in the future.
/// Implements IComparable (CustomComparison) based on the comparison of the time property.
/// CustomEquality is implemented for the comparisons <= and >=.
[<CustomEquality; CustomComparison>]
type Command<'Time, 'Action when 'Time : comparison and 'Action : equality> = 
    { Time : 'Time
      Action : 'Action }
    
    override this.Equals obj = 
        match obj with
        | :? Command<'Time, 'Action> as other -> (this.Time = other.Time) && (this.Action = other.Action)
        | _ -> false
    
    override x.GetHashCode() = hash x
    interface System.IComparable with
        member this.CompareTo obj = 
            match obj with
            | :? Command<'Time, 'Action> as other -> compare this.Time other.Time
            | _ -> invalidArg "yobj" "cannot compare value of different types"

/// Represents an Schedule of future commands, i.e. upcoming events.
type Schedule<'Command when 'Command : comparison> = 
    | Schedule of 'Command list

module Schedule = 
    /// The generic empty Schedule.
    let empty = Schedule []
    
    /// Check if the Schedule is empty.
    let isEmpty schedule = (schedule = empty)
    
    /// Return the next command and the remaining schedule.
    let next schedule = 
        match schedule with
        | Schedule [] -> Result.Failure "Schedule is empty", schedule
        | Schedule(head :: tail) -> Result.Success head, Schedule tail
    
    /// Return the time of the next command in the schedule.
    let getTimeOfNextCommand schedule = 
        match schedule with
        | Schedule [] -> Result.Failure "Schedule is empty"
        | Schedule(head :: _) -> Result.Success head.Time
    
    /// Add a new command to the schedule by recreating the schedule list from the tail 
    /// and inserting new command just after the last command with the same timestamp.
    let add schedule command = 
        match schedule with
        | Schedule [] -> Schedule [ command ]
        | Schedule list -> 
            let folder x accList = 
                match accList with
                | [] -> [ x ]
                | [ head ] -> 
                    if x <= head then [ x; head ]
                    else [ head; x ]
                | head :: tail -> 
                    if x <= head then x :: head :: tail
                    else head :: x :: tail
            List.foldBack folder list [ command ] |> Schedule
    
    /// Add a sequence of commands to a schedule and return the new schedule.
    let addSeq schedule commands = Seq.fold add schedule commands
    
    /// Create a schedule from a sequence of commands.
    let ofSeq commands = addSeq empty commands

/// Represents a model given an initial state, a function that executes commands
/// on the state to generate events and a function to apply the an event to a state
/// returning the new state and a list of new commands generated by the event and 
/// the change of state.
type Model<'State, 'Command, 'Event> = 
    { /// The initial state of the model.
      InitialState : 'State
      /// Executes a command on a state yielding an event.
      Execute : 'State -> 'Command -> 'Event list
      /// Applies an event to the state returning a new state 
      /// and a (possibly empty) list of new commands that are 
      /// generated by the system due to the event
      Apply : 'State -> 'Event -> ('State * 'Command list) }

/// Represents a simulation run that is not finished yet, i.e. it hosts 
/// a model, its currents state and currents schedule of commands.
type SimRun<'State, 'Command, 'Event when 'Command : comparison> = 
    { Model : Model<'State, 'Command, 'Event>
      State : 'State
      Schedule : Schedule<'Command> }

/// Represents a simulation that is either still running or terminated.
type Simulation<'State, 'Command, 'Event when 'Command : comparison> = 
    | SimRun of SimRun<'State, 'Command, 'Event>
    | SimTerminated

module Simulation = 
    /// Evolve a simulation run up to the next command in the schudule.
    let private evolveRun saveEvent log run = 
        // Get the next command if there is any.
        let (nextCommandResult, remainingSchedule) = Schedule.next run.Schedule
        // Because nextCommandResult is a Result<Command,string> and not a Command
        // we first define function to act on the command etc. and then map them to
        // the Result<> world.
        // Turning the command into an event list
        let executeCommand command = run.Model.Execute run.State command
        
        // Applying the event list which change the state and collecting the new commands
        //TODO: this should rather be done in three steps:
        //  1. apply events and return new state and commands
        //  2. store events
        //  3. add new commands to schedule
        let applyEventsAndScheduleNewCommands eventList = 
            let folder (state, schedule) event = 
                let (newState, commands) = run.Model.Apply state event
                sprintf "Event '%A' generated %i commands" event commands.Length |> log
                saveEvent event
                let newSchedule = Schedule.addSeq schedule commands
                (newState, newSchedule)
            Seq.fold folder (run.State, remainingSchedule) eventList
        // Now take the command ...
        nextCommandResult
        // ... execute it to get a list of events
        |> Result.mapR executeCommand
        // ... apply the events to the state, save the events, return new state and new schedule
        |> Result.mapR applyEventsAndScheduleNewCommands
        // ... return the run with new state and new schedule
        |> Result.mapR (fun (state, schedule) -> 
               { run with State = state
                          Schedule = schedule })
    
    /// Evolve a simulation run up to the next command in the schudule.
    let evolveSim saveEvent log simulation = 
        match simulation with
        | SimTerminated -> 
            log "Simulaten terminated"
            SimTerminated
        | SimRun run -> 
            match evolveRun saveEvent log run with
            | Success newRun -> SimRun newRun
            | Failure msg -> 
                sprintf "Simulaten terminated: %s" msg |> log
                SimTerminated
    
    /// Run a simulation until it is terminated.
    let run saveEvent log simulation = 
        let isRunning = 
            function 
            | SimRun _ -> true
            | SimTerminated -> false
        
        let mutable sim = simulation
        while isRunning sim do
            sim <- evolveSim saveEvent log sim
        sim
    
    /// Create a new simulation.
    let create model state schedule = 
        SimRun { Model = model
                 State = state
                 Schedule = schedule }
    
    /// Create a new simulation using the initial state of the model as initial state
    /// for the simulation.
    let createInitial model schedule = create model model.InitialState schedule
